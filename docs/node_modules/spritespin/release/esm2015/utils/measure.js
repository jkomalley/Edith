import { detectSubsampling } from './detectSubsampling';
import { naturalSize } from './naturalSize';
/**
 * Measures the image frames that are used in the given data object
 */
export function measure(images, options) {
    if (images.length === 1) {
        return [measureSheet(images[0], options)];
    }
    else if (options.framesX && options.framesY) {
        return measureMutipleSheets(images, options);
    }
    else {
        return measureFrames(images, options);
    }
}
function measureSheet(image, options) {
    const result = { id: 0, sprites: [] };
    measureImage(image, options, result);
    const frames = options.frames;
    const framesX = Number(options.framesX) || frames;
    const framesY = Math.ceil(frames / framesX);
    const frameWidth = Math.floor(result.width / framesX);
    const frameHeight = Math.floor(result.height / framesY);
    const divisor = result.isSubsampled ? 2 : 1;
    for (let i = 0; i < frames; i++) {
        const x = (i % framesX) * frameWidth;
        const y = Math.floor(i / framesX) * frameHeight;
        result.sprites.push({
            id: i,
            x: x, y: y,
            width: frameWidth,
            height: frameHeight,
            sampledX: x / divisor,
            sampledY: y / divisor,
            sampledWidth: frameWidth / divisor,
            sampledHeight: frameHeight / divisor
        });
    }
    return result;
}
function measureFrames(images, options) {
    const result = [];
    for (let id = 0; id < images.length; id++) {
        // TODO: optimize
        // don't measure images with same size twice
        const sheet = measureSheet(images[id], { frames: 1, framesX: 1, detectSubsampling: options.detectSubsampling });
        sheet.id = id;
        result.push(sheet);
    }
    return result;
}
function measureMutipleSheets(images, options) {
    const result = [];
    for (let id = 0; id < images.length; id++) {
        // TODO: optimize
        // don't measure images with same size twice
        const sheet = measureSheet(images[id], {
            frames: undefined,
            framesX: options.framesX,
            framesY: options.framesY,
            detectSubsampling: options.detectSubsampling
        });
        sheet.id = id;
        result.push(sheet);
    }
    return result;
}
function measureImage(image, options, result) {
    const size = naturalSize(image);
    result.isSubsampled = options.detectSubsampling && detectSubsampling(image, size.width, size.height);
    result.width = size.width;
    result.height = size.height;
    result.sampledWidth = size.width / (result.isSubsampled ? 2 : 1);
    result.sampledHeight = size.height / (result.isSubsampled ? 2 : 1);
    return result;
}
export function findSpecs(metrics, frames, frame, lane) {
    let spriteId = lane * frames + frame;
    let sheetId = 0;
    let sprite = null;
    let sheet = null;
    while (true) {
        sheet = metrics[sheetId];
        if (!sheet) {
            break;
        }
        if (spriteId >= sheet.sprites.length) {
            spriteId -= sheet.sprites.length;
            sheetId++;
            continue;
        }
        sprite = sheet.sprites[spriteId];
        break;
    }
    return { sprite, sheet };
}
//# sourceMappingURL=measure.js.map